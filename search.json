[
  {
    "objectID": "Preprocessing_data/index.html",
    "href": "Preprocessing_data/index.html",
    "title": "Preprocessing GEO transcriptomic data",
    "section": "",
    "text": "About expression values\n\nGene expression matrices downloaded from GEO can vary in their preprocessing status. The values you download are not always the ones directly obtained from the measurement technologies, such as raw luminescence values or raw counts (known as raw data) . Often, data is uploaded to databases with prior preprocessing done by the authors who provide them. You can usually find the following formats:\n\nRaw data: These are the original data directly obtained from experiments, such as microarray signal intensities or sequencing counts. These data often require additional preprocessing and normalization steps before being used in comparative analyses.\nNormalized data: In some cases, the data on GEO have already been normalized using specific methods (such as RMA for microarrays or TPM for RNA-seq). However, this depends on how the data were uploaded by the researchers. In microarrays, normalization is mainly performed to correct technical variations in fluorescence intensities between probes and samples. This includes steps such as background correction and signal distribution equalization using techniques like RMA or MAS5, resulting in a single value per gene after probe summarization (a process of combining multiple probes or RNA reads from different regions of the same gene into a single expression value, typically using the mean or median). In RNA-seq, probes are not involved, as reads aligning to each genomic region are counted directly. Here, normalization focuses on adjusting for differences in sequencing depth and gene length, using metrics like TPM, FPKM, or RPKM to reflect the relative abundance.\n\nChecking the metadata will help you identify if the data has already been normalized or if you will need to perform this step manually before conducting any analyses. You can explore the ‘data_processing’ column from the metadata. Let´s see an example:\n\ngse1 &lt;- getGEO(\"GSE39582\", GSEMatrix = TRUE) # Here, I randomly called the data from the GSE39582 series 'gse1'\ngse1_data &lt;- gse1[[1]] \nmetadata1 &lt;- pData(gse1_data)\nmetadata1$data_processing\nOutput:  [1] \"RMA normalisation (Bioconductor R affy package) + ComBat (R sva package )\"    \n[2] \"RMA normalisation (Bioconductor R affy package) + ComBat (R sva package )\"     \n[3] \"RMA normalisation (Bioconductor R affy package) + ComBat (R sva package )\"     \n[4] \"RMA normalisation (Bioconductor R affy package) + ComBat (R sva package )\"  \n...  \n[585] \"RMA normalisation (Bioconductor R affy package) + ComBat (R sva package )\"\n\nHere we can see that the expression values in the gene expression matrix we downloaded are not raw counts but have already been normalized using RMA. Additionally, a technique called ComBat was used to merge matrices from different studies, removing non-biological variability.\nAlso if you go to the GEO webpage and search for the code of the data series you are interested in, you can access the list of individual samples within the series. If you click on a sample and scroll down to the end of the page, you will find a section of the expression matrix for that specific sample. There, the ‘VALUE’ field indicates whether the expression value corresponds to any preprocessing or normalization method. Here is an example—scroll to the end of the page.\n\n\n\nFiltering samples\n\nIf you’re not interested in all the samples within a GEO series, you can create a list by filtering the samples directly from the metadata to retain only the patients you’re interested in. You can explore the column names of the metadata to identify the fields that could be important for you analysis.\nFor example, in the analysis of this article, I was specifically interested in patients treated with 5-FU, so I performed a search in GEO and chose the series GSE39582. I explored the metadata column names of GSE39582 using the colnames command. I identified a column called “chemotherapy.adjuvant.type:ch1”, which contains information about the patients’ treatments. Using this column, I filtered only the samples of patients treated with 5-FU.\nLet’s see this with code:\n\ntable(metadata1$`chemotherapy.adjuvant.type:ch1`)# To obtain a summary of the information in a column, you can use the 'table' command.\n\nOutput:\n 5FU FOLFIRI  FOLFOX   FUFOL     N/A   other       \n 82      12      23      54     411       3 \nHere, we see that we can use 82 samples from patients treated with 5-FU to perform the analysis. Let’s filter these:\n\n\n# Filter the patients of interest\nfiltered_patients &lt;- metadata1[metadata1$`chemotherapy.adjuvant.type:ch1` == '5FU', ] # Here is important that you conntrol how is writen the name of the treatrment, for example, in this case '5-FU\" is written as \"5FU\" (without hyphen)\n\n# Get the sample names that meet the criteria\nsample_ids &lt;- rownames(filtered_patients) #Here, I used 'rownames' because in the metadata, samples (or patients) are in the rows instead of the columns-\n\n# Filter the gene expression data for the samples of interest\nfiltered_expression_data &lt;- exprs(gse1_data)[, sample_ids]\nNow, filtered_expression_data is a data.frame that contains only 82 columns, which correspond to the 82 patients treated with 5-FU and 54675 probes.\n\n\nExploring the data\n\nRegardless of the technology used to obtain the gene expression values, before starting any type of analysis, it is advisable to perform an exploratory boxplot. If the data you downloaded is in raw format, you should expect to see misaligned boxplots across the samples. However, if the data is normalized and the normalization was successful, all the boxes in the boxplot should be approximately at the same level (same median and similar interquartile range). This indicates that the variation among the samples has been standardized.\nRemember that boxplots are used to show the distribution of gene expression values for each sample before and after normalization. The purpose of creating this plot is to verify whether the samples are comparable to each other, which is crucial to avoid biases in subsequent analyses.\nOther aspects to observe in your boxplot to verify successful normalization are the outliers, as points outside the ‘boxes’ represent atypical values. An excessive number of outliers or significant dispersion among the samples may suggest that the normalization was inadequate.\nYou should also observe the height of the boxes. The boxes (interquartile range) show the dispersion of the values; significant differences in the height of the boxes between samples could indicate issues with the normalization.\n\n# Following the example from the publication:\npar(mar = c(7, 4, 4, 2))     #Adjust the sheet margins (useful when the axis labels are long).\nboxplot(\n  filtered_expression_data,  # Data to plot (filtered expression data)\n  col = rainbow(82),         # Color the boxes with a rainbow palette of 82 colors\n  las = 2,                   # Rotate axis labels to 90 degrees\n  ylab = \"Luminescence\",     # Label the y-axis as \"Luminescence\"\n  xlab = \"\",                 # No label for the x-axis\n  cex.axis = 0.7,            # Set the axis label size to 70% of default\n  outcex = 0.35,             # Size of outlier points (smaller than default)\n  outcol = \"red\"             # Color outlier points in red\n)\n\n# Add a label \"SampleID\" to the x-axis, with a specific position (line 5)\nmtext(\"SampleID\", side = 1, line = 5)\n\n## If you want to save the image directly on your computer (in pdf format), you can try:\npdf(file=\"GSE81653_boxplot.pdf\", pointsize=8, width=10, height=5)\npar(mar = c(7, 4, 4, 2))\nboxplot(\n        filtered_expression_data, \n        col = rainbow(82), \n        las = 2,\n        ylab = \"Luminescence\", \n        xlab = \"\",\n        cex.axis = 0.7, \n        outcex = 0.35, \n        outcol = \"red\"\n)\nmtext(\"SampleID\", side = 1, line = 5)\ndev.off()\n\nIn the graph, we can see that there are many outliers in the upper part of the distribution. You may frequently encounter this when analyzing microarray data. Before exploring other potential technical or biological reasons, the most convenient approach is to filter out the probes that have low luminescence, meaning probes whose luminescence is very similar to the background luminescence of the chip. Often, if there are many of these probes, they tend to “pull down” the luminescence values, causing outliers that are actually informative. Let’s see how to do this:\n\n#Visualization and selection to intensity cut-off\n#Affy\nmedian_expresion &lt;- rowMedians(Biobase::exprs(cnedata))\nname = \"5fu hist_res normalized.pdf\"\npdf(file=name,pointsize=10,width=10, heigh=10)\nhist(median_expresion, 100, col = \"cornsilk1\", freq = FALSE, \n            main = \"Histogram of the median intensities\", \n            border = \"antiquewhite4\",\n            xlab = \"Median intensities\")\ndev.off()\n\n#Oligo\nmedian_expresion &lt;- rowMedians(Biobase::exprs(ndata))\nname = \"5fu hist_res normalized3.pdf\"\npdf(file=name,pointsize=10,width=10, heigh=10)\noligo::hist(median_expresion,100, col = \"cornsilk1\", freq = FALSE, \n            main = \"Histogram of the median intensities\", \n            border = \"antiquewhite4\",\n            xlab = \"Median intensities\")\ndev.off()\n\nsamples_cutoff&lt;-14\nman_threshold&lt;-8\nidx_man_threshold &lt;- apply(Biobase::exprs(cnedata), 1,\n                           function(x){\n                          sum(x &gt; man_threshold) &gt;= samples_cutoff})\n                          table(idx_man_threshold)\n\nifdata &lt;- subset(cnedata, idx_man_threshold)\n\n\nWhat should I do if my data is not normalized?\n\nTo normalize gene expression data measured by microarrays in R, there are several commonly used methods depending on the data type and experimental design:\n\nRMA (Robust Multi-array Average): his method is one of the most popular for normalizing Affymetrix microarray data. It includes background correction, quantile normalization, and expression summarization.\nR Package: affy or oligo (for Affymetrix data). Keep in mind that the affy package is designed to normalize data from older microarrays, such as the HG-U133 series. In contrast, the oligo package allows for the normalization of data from newer generation Affymetrix chips and other platforms like NimbleGen and Exon arrays.\nQuantile Normalization: Adjusts the distribution of expression values across samples to have the same distribution, which helps reduce technical variability.\n\nR Package: preprocessCore.\n\nLoess Normalization: Mainly used for normalizing two-color microarray data, adjusts the intensity of each sample to correct intensity-dependent effects.\n\nR Package: limma.\n\nVSN (Variance Stabilizing Normalization): This method transforms the data to stabilize the variance as a function of the mean, minimizing intensity-dependent effects.\n\nR Package: vsn.\n\nMAS5 Normalization: An older method but still used in some analyses of Affymetrix data.\n\nR Package: affy.\n\n\nAmong the options mentioned, the RMA method has been the most widely used in the scientific community due to its flexibility and advanced preprocessing options. Keep in mind that normalization using the oligo package can be more demanding in terms of computational resources, which is an important factor to consider when working with large volumes of data.\nTo load your samples into the working environment, you need to download them in .CEL format to a folder set as your working directory. Often, samples are downloaded in compressed files along with their metadata. If that’s the case, you need to unzip them and place the .CEL files in a separate folder, as having other types of files in the folder read by the affy function can cause errors during loading.",
    "crumbs": [
      "Preprocessing the data"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome",
    "section": "",
    "text": "This WebGuide provides an overview of the code and workflow used for transcriptomic data analysis in the publication: “Overcoming Therapy Resistance in Colorectal Cancer: Targeting the Rac1 Signaling Pathway as a Potential Therapeutic Approach”\n🔗 You can access the full publication here\n⚠️ Note: Some sections are still under construction (🚧). Updates will be added soon!",
    "crumbs": [
      "About this WebGuide"
    ]
  },
  {
    "objectID": "Searching_data/index.html",
    "href": "Searching_data/index.html",
    "title": "Search and download of transcriptomic data from the GEO database",
    "section": "",
    "text": "Where to search human data gene expression?\n\nFor searching human gene expression data, you can explore several major public databases and repositories that host a wide range of gene expression datasets. Here are some key resources:\n\nGene Expression Omnibus - NCBI: A comprehensive public repository for gene expression data, including both raw and processed data\nArrayExpress &lt; BioStudies &lt; EMBL-EBI: A database of functional genomics experiments, including gene expression data from various platforms.\nThe Cancer Genome Atlas Program (TCGA) - NCI: Provides data on gene expression and other genomics for various types of cancer.\nExpression Project for Oncology (expO): collects gene expression data obtained from tumor samples, allowing researchers to explore how gene expression patterns change in the context of cancer. Includes gene expression data in different types of cancer, both in tumor conditions and in comparative normal samples.\ncBioPortal for Cancer Genomics: This platform brings together studies from various databases and allows you to download both sequencing and mutation and clinical data.\n\n\nIn this workflow, we will focus on the GEO database, as the data selected for the study were specifically downloaded from there.\n\n\nAbout GEO\n\nGEO (Gene Expression Omnibus) is a public repository for genomic data. Its primary purpose is to store and share data from gene expression experiments, where the activity of genes is analyzed under different conditions or cell types. GEO serves as a centralized source for researchers to share their data with the scientific community, allowing others to reuse this data in new analyses or comparative studies.\nGEO stores various types of biological data, including:\n\nGene expression data: Information about gene expression levels under different conditions, such as tissues, cell types, cell lines, or in response to specific treatments. This includes data from microarrays and RNA-seq.\nDNA and RNA sequencing data: Results from sequencing experiments, including RNA-seq (transcriptomes), ChIP-seq (protein-DNA interactions), and ATAC-seq (chromatin accessibility).\nGenotyping and genetic variant data: Information about genomic variations, such as single nucleotide polymorphisms (SNPs), structural variants, and mutations, obtained from GWAS studies or other approaches.\nMetadata: Descriptions of samples, including biological characteristics (e.g., age, sex, or disease state), experimental conditions (treatments, exposure times), and protocols used.\nEpigenetic profiles: Data related to epigenetic modifications, such as DNA methylation patterns or histone modifications.\nMolecular interaction data: Information from experiments like RIP-seq or CLIP-seq that identify interactions between molecules, such as RNA-RNA or protein-RNA interactions.\nRaw count matrices: Files containing raw data from sequencing or microarray experiments, allowing for customized analyses.\nChromatin accessibility profiles: Data from assays like DNase-seq or ATAC-seq, revealing accessible regions of the genome.\n\n\n\n\nHow Data is Stored in GEO (Under Construction 🚧)\n\n\nAbout GEOquery\n\nGEOquery is a package in the R programming language that facilitates downloading and manipulating datasets from the GEO database. It is used to access various types of genomic data, such as gene expression matrices, time series data, and study metadata, directly from R, without the need to manually download them from the GEO website.\nFirst, you need to install the package in R if you haven’t already. This can be done by running:\n\ninstall.packages(\"BiocManager\")\nBiocManager::install(\"GEOquery\")\n\nThen, you need to load GEOquery in your R session\n\nlibrary(GEOquery)\n\nTo download data from GEO, you need to know the dataset identifier (e.g., “GSEXXXX”). You can read about how GEO organizes its information [here] and also learn how to perform a data search in GEO [here]. Once you have chosen your dataset, you can use the getGEO function to fetch it.\n\ngse &lt;- getGEO(\"GSEXXXX\", GSEMatrix = TRUE) #Here, GSEXXXX is your selected GEO series, for example, GSE39582\n\nWhere GSEMatrix = TRUE indicates that you want the expression data in matrix form, which is common in many analyses.\n\n\n\nWhat do I download when I use the GEOQuery getGeo function?\n\nGene expression data in R is most often downloaded as a data structure called “ExpressionSet” which is an S4 type object. An S4 object is a way to organize and work with data in R. Think of it as a box that can hold different types of data and knows what to do with it based on how it is labeled (its “class”). Inside this box, you can have various components, such as expression data and metadata (clinical data, data about how the experiment was performed, etc.). The label (or “class”) of the box tells R what kind of data it is handling and what functions to use to work with it. To work with S4 objects, you can use generic functions and methods specific to those objects. Here are some examples:\nData Access:\nexprs(): with this method retrieves the gene expression matrix.\npData(): this method retrieves information about each samples (metadata).\nfData(): this method retrieves information about the features (probes or reads) measured by the technology (chip or sequencer).\nexperimentData(): this method provides general metadata about the experiment, such as drugs, doses, time points, gene silencing, etc.\nannotation(): information about the platform (name, model, etc.).\nLet’s see this whit code:\n\nlibrary(GEOquery)\n\n# Download data from GEO\ngse &lt;- getGEO(\"GSEXXXX\", GSEMatrix = TRUE) #Here, GSEXXXX is your selected GEO series, for example, GSE39582.\n\n# The GEOSerie information is saved in a list that always has one element, but this element is an ExpressionSet class object, which is associated with the methods. \ngse_data &lt;- gse[[1]] # If you try something like \"gse_data &lt;- gse[[2]]\" you will obtain an error\n\n# Access the expression matrix\nexpression_data &lt;- exprs(gse_data)\n\n# Access the metadata\nmetadata &lt;- pData(gse_data)\n\n# Access the feature data\nfeature_data &lt;- fData(gse_data) # Usually, here you can find information about the probes, for example, the gene symbol associated with the probe, the ENTREZ_ID and the gene ontology.\n\n# Access the experiment general information \nexperiment_data &lt;- fData(gse_data) # here, you can find information about, for example, the last date the dataset was modified or the email of the contact person for questions.\n\n# Access the plataform name\nplataform&lt;-annotation(gse_data)\n\nIn the image above, you can observe a schematic representation of how an object of the ExpressionSet type is structured.\n\n\nHow is the gene expression matrix organized?\n\nThe information in the expression matrix will depend on the technique used to obtain the gene expression values. The two most common technologies today are microarrays (chips) and RNA sequencing (RNA-seq or high-throughput platforms).\nWhen you execute expression_data &lt;- exprs(gse_data), you save a matrix object with the name “expression”\nIn the case of microarrays, this object has the following characteristics:\n\nProbes are in rows: a probe is a small DNA (or RNA) sequence designed to bind (hybridize) to a specific sequence of interest. Each gene is typically represented by multiple probes. If you want to know more about how microarrays work, I recommend this amazing video (link). The important thing here is that the probe names in the rows are written with a chip-specific code.\nSamples are in columns: each column of the expression matrix represents a patient or a sample. The samples also have a specific code, whose structure depends on the researchers performing the analysis. In the case of the GEO database, the samples always begin with “GSM” followed by a number, for example, GSM972020. But keep in mind that if you plan to download gene expression data from other databases, the sample codes might be very different.\nThe expression values are in the cells: for microarrays, the gene expression values represent the “luminescence” (light intensity) emitted by the hybridization between the RNA entering the chip’s well and the specific probe it contains.\n\n\n\n\nIn the case of RNA-seq, the object has little differences:\n\nGenes names or code are in rows (there are no probes because the technique relies on the direct sequencing of RNA fragments). Usually, you can find official gene name , ENTEREZ ID or ENSAMBLE IDs in rows.\nThe columns continue to be the patients or samples.\nValues in the cells now are “read count”, it represent the number of RNA fragments that align with a specific region of the genome or a particular gene. They are an approximate measure of the RNA abundance representing a gene in the sample.",
    "crumbs": [
      "Search and download of transcriptomic data from GEO"
    ]
  }
]